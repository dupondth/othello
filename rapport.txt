**INTRODUCTION**

	Othello, aussi connu sous le nom de Réversi, est un jeu de stratégie à deux joueurs.  Il se joue sur un plateau de 64 cases appelé othellier. Les joueurs disposent de 64 pions bicolores, noirs d'un côté et blancs de l'autre. Un pion est dit noir (respectivement blanc) si sa face visible est celle de couleur noire (respectivement blanc). Le but du jeu est d'avoir plus de pions que son adversaire à la fin de la partie. C'est par ailleurs un jeu dit à somme nulle : ce que gagne l'un est nécessairement perdu par l'autre. Le jeu se termine lorsque le plateau est rempli ou qu'aucun des deux joueurs ne peut plus jouer de coup qui soit légal.

	Les règles retenues pour notre projet sont les règles classiques, aucune hypothèse simplificatrice ne sera faite. Ces règles sont donc les suivantes:
- au début de la partie, deux pions noirs sont placés en e4 et d5 et deux pions blancs sont placés en d4 et e5 [plateau_initial.png].
- le joueur ayant les pions Noir commence toujours et les deux adversaires jouent ensuite à tour de rôle.
- le jeu se joue tour par tour.
- le joueur pose un pion de sa couleur sur une case vide de l'othellier, adjacente à un pion adverse. Il doit également, en posant son pion, encadrer un ou plusieurs pions adverses entre le pion qu'il pose et un pion à sa couleur, déjà placé sur l'othellier (schema_jeu.png).
- s'il ne peut pas réaliser un coup légal, le joueur passe son tour.

	Les objectifs de ce projet sont multiples. Tout d'abord, nous devons implémenter les règles d'Othello dans un écosystème qui rassemble tous les éléments de l'environnement du jeu. Il nous faudra aussi mettre en place d'un banc de test en parallèle de la programmation du jeu afin de détecter les erreurs et éviter leur accumulation. Nous devons également développer des intelligences artificielles afin de les faire jouer contre des humains. Finalement nous devons mettre en place une interface homme-machine permettant à un humain de jouer facilement et de profiter de toutes les fonctionnalités de notre programme. Ce projet s'articulera autour de la programmation orientée objet et de divers modules et techniques présentés en cours : Unittest, PyQt et ses modules, QtDesigner, PyNSource, les techniques d'encapsulation, la génération de documentation python etc.



**ANALYSE DES PROBLEMATIQUES DU JEU**


SCHEMA D'UN COUP

Validité du coup:
	Un joueur ne peut jouer un pion que s'il existe une case jouable sur le plateau. Pour s'assurer qu'une case est jouable, nous disposons d'un système de vérification dans l'écosystème (le fichier plateau.py) constitué tout d'abord d'une fonction coupValide. Cette fonction retourne un couple composé d'un booléen et d'une liste de positions. Si la case étudiée est valide, elle renvoie True et la liste des positions des pions adverses à retourner. Sinon, elle renvoie False et une liste vide.
	Dans un premier temps, coupValide va vérifier que la case de départ se situe bien dans les limites du plateau. Si c'est le cas, la fonction va ensuite sélectionner chacune des huit directions à explorer, afin de savoir si des pions adverses peuvent être retournés. Les huit directions possibles ont été définies au préalable dans la fonction increment.
	Une fois toutes les directions  explorées et si des pions adverses peuvent effectivement être gagnés par le joueur, la fonction coupValide rend un couple (True,[liste des pions adverses à retourner]). 

Réalisation du coup:
	C'est ensuite la fonction retourner qui intervient. Placé dans la classe joueur, son rôle est de poser le pion que le joueur veut jouer et de retourner les pions adverses qu'il a gagnés. Pour cela, elle utilise les informations données par coupValide : elle s'assure que la validité du coup vaut True, puis elle parcourt la liste des pions adverses à retourner et les retourne un par un. Dans tous les cas où la case n'est pas jouable (coupValide rend False), la fonction retourner lève une exception ValueError, ce qui permettra à la fonction responsable du bon déroulement de la partie de demander au joueur de joueur sur une case valide.


SCHEMA D'UNE PARTIE

	Les parties sont gérées dans le fichier applicationIHM.py qui utilise en plus des fonctions et objets définis dans le fichier plateau.py.

Initialisation du plateau de jeu:
	Pour commencer une partie d'Othello, il faut d'abord créer un plateau de jeu. Nous utilisons pour cela une fonction generer. Cette fonction crée un objet de type plateau dont les caractéristiques sont décrites dans la classe plateau de l'écosystème. Le plateau est représenté par un dictionnaire. Les clés de ce dictionnaire sont les coordonnées des positions occupées par des pions, les valeurs sont objets pion noirs ou blancs. Les objets pion ainsi créés sont caractérisés par leur position et leur couleur. [[Le choix d'un dictionnaire se justifie par...]]. Le plateau qui est créé contient dans un premier temps quatre pions (deux blancs et deux noirs) disposés selon les règles du jeu. Cette disposition d'origine est automatiquement crée lorsque que le fichier applicationIHM.py est exécuté.

Initialisation des joueurs:
	La fonction generer nous permet également d'initialiser les joueurs. Elle crée deux objets de type joueur, un joueur blanc et un joueur noir, en les sélectionnant parmi les classes filles de la classe joueur. Ces sous-classes définissent chacune un type de joueur (humain ou intelligence artificielle). Les joueurs sont sélectionnés selon l'option choisie par l'utilisateur dans l'interface homme-machine (Humain vs Humain, Humain vs IA, IA vs IA).

Exécution du jeu et réalisation d'un tour:
	La gestion d'une partie entière se fait au travers de deux tâches : la gestion d'un tour et la gestion de la succession des tours jusqu'à ce que les joueurs ne puissent plus jouer.
	Commençons par la gestion d'un tour, qui se définit comme la succession d'un coup du joueur noir suivi d'un coup du joueur blanc. Nous disposons pour cela de plusieurs fonctions tour qui se déclinent selon le mode de jeu choisi. Cette fonction fait jouer les deux joueurs l'un après l'autre, en vérifiant à chaque fois que le joueur dispose de cases sur lesquelles il peut jouer. Si tel est le cas, le joueur joue sur la case qu'il a choisie et le plateau est mis à jour et affiché. Si toutefois son coup n'est pas valide, une exception de type ValueError se déclenche, ce qui empêche le plateau d'être modifié et génère un message d'erreur pour que le joueur joue de nouveau. Si un joueur ne dispose pas de case jouable, il passe son tour. 
	La succession des tours est gérée par la fonction partie. En plus d'exécuter la fonction tour et de compter les tours, cette fonction permet également d'arrêter le jeu. En effet, la fonction tour renvoie un booléen False si les deux joueurs ne peuvent successivement plus jouer, ce qui correspond à la fin de la partie (situation de blocage ou plateau rempli). A chaque tour, la fonction partie teste ce booléen pour savoir si elle doit continuer ou non la partie.


TYPES DE JOUEURS

	Notre implémentation du jeu Othello permet de faire s'affronter plusieurs types de joueurs : humain contre humain, humain contre IA ou IA contre IA. Nous avons donc créé une classe joueur et des sous-classes représentant chacune un type de joueur qui héritent des propriétés communes des joueurs. Ainsi, tous les joueurs ont une couleur, jouent sur un plateau et doivent respecter un périmètre de jeu. La variable couleur est encapsulée afin de ne pas être modifiée par inadvertance. Tous les joueurs utilisent par ailleurs la méthode retourner (décrite précédemment).

Joueur humain:
	Deux versions de joueurs humains ont été créées. La première version permet à l'utilisateur d'intérargir avec l'affichage graphique dans la console python : elle demande au joueur d'entrer les coordonnées de la case sur laquelle il veut jouer et elle lui permet de quitter la partie en entrant la commande "q". La deuxième version du joueur humain, nommée humain_graphique, ne nécessite plus de demander une case ou de permettre au joueur de quitter étant donné que l'IHM gère tout cela elle-même.

IAalea et IAmax (premières IA):
	Avant d'implémenter des IA complexes, nous avons choisi de créer deux IA simples qui nous permettraient de tester facilement le reste de notre programme. La première IA joue aléatoirement et la seconde maximise le nombre de pions adverses gagnés sans anticiper le jeu de l'adversaire. Nous pouvons ainsi vérifier que notre gestion des tours est correcte en observant le déroulement d'une partie opposant une IA à un humain, à une autre IA ou à elle-même. Ces deux IA nous permettront aussi d'évaluer l'intelligence des IA qui seront programmées par la suite. Par ailleurs, l'implémentation de ces deux IA est pertinente puisque leur comportement reflète le comportement souvent adopté par des joueurs humains novices. Elles pourraint faire ainsi office d'adversaires de niveau intermédiaire. Dans ce même esprit de niveaux de jeu, nous aurions également pu créer une IAmin qui miniserait le gain de chacun de ses coups pour en faire un niveau de jeu facile.

IA Min-Max:
	L'algorithme minmax est un algorithme de jeu particulièrement bien adapté aux jeux à deux joueurs et à somme nulle (ce qui est le cas d'Othello). Le principe de minmax est de maximiser le gain minimal du joueur (ou minimiser ses pertes maximales). Pour cela, il part de l'état actuel du jeu et va étudier tous les scénarios possibles jusqu'à une certaine "profondeur", suite à quoi il attribue une valeur à chaque coup jouable. Cette valeur, aussi appelée poids d'un coup, s'obtient en simulant un ou plusieurs tours : c'est la profondeur de l'algorithme minmax, qui correspond au nombre de tour que l'on simule [1]. L'image ci-contre [schema_minmax.png] montre un exemple de simulation sur un tour: à l'état initial le joueur a trois coups possibles puis l'adversaire a lui-même un certain nombre de coups possibles. Les valeurs affichées à l'état n+2 correspondent aux variations des points du joueur. Dans un premier temps, l'algorithme cherche le gain minimal (ou le perte maximale) pour chacun des coups possibles du joueur puis il attribue cette valeur au coup. L'algorithme cherche ensuite le maximum de ces valeurs parmi tous les coups possibles, puis il sélectionne la position associée à ce maximum, et joue enfin sur cette position. On suppose donc que l'adversaire joue à chaque fois de sorte à maximiser son gain. Nous utiliserons pour calculer la variation de points une fonction nommée diff_score qui rend la différence de points pour un joueur donné.
	Une deuxième version de minmax, nommée minmax2, a été programmée et reprend le principe de minmax mais avec un degré de profondeur supplémentaire. Elle simule en effet deux tours, ce qui améliore son niveau de jeu mais la rend du même coup plus lente.
	
Variantes de Min-Max:
	Il existe des simplifications de min-max lorsque celui-ci est codé de manière récursive (ce qui n'est pas notre cas). En effet, un algorithme min-max récursif doit faire une distinction entre les noeuds joueur et les noeuds adversaire. Parmi ces simplifications, nega-max est une version qui permet de ne plus faire la distinction entre ces deux types de noeuds et qui "repose sur le constat que minimiser une valeur revient à maximiser l’opposé de cette valeur" [2]. Une autre version simplificatrice fréquemment utilisée est la méthode alpha-bêta, aussi appelée élagage alpha-bêta. Elle permet de sélectionner uniquement les sous-arbres qu'il est nécessaire d'explorer via la méthode min-max et d'éliminer tous les autres. On évite ainsi de faire une exploration complète jusqu'à une profondeur donnée contrairement à ce que fait l'algorithme min-max basique [3].


INTERACTION AVEC L'UTILISATEUR:

Affichage graphique:
	Nous avons dans un premier temps créé une IHM dans la console IPython. Bien que très simple, elle permet à un joueur humain de jouer et nous permet d'observer facilement le déroulement d'une partie. Les colonnes sont nommées de A à H, les lignes sont numérotées de 1 à 8, les pions noirs et blancs sont respectivement représentés par 'N' et 'B' et les cases jouables sont signalés par '#'. Cette interface est gérée par la fonction affichage de la classe plateau.
	Dans un second temps, nous avons créé une IHM à partir de QtDesigner et de PyQt. Celle-ci possède son propre fichier Python nommé applicationIHM.py. Ce fichier comprend les fonctions qui gèrent le déroulement des parties auquel nous ajoutons la gestion de l'affichage. Cette version bien plus complète doit répondre à deux critères principaux:  l'affichage dynamique et "réaliste" du plateau de jeu et l'intégration de toutes les options de jeu. Pour cela, la fenêtre de notre application est constituée d'un grand conteneur pour héberger le plateau et de boutons pour commander toutes les options. Le conteneur se compose d'un arrière-plan représentant le quadrillage (créé sur Paint) et de disques noirs ou blancs qui apparaissent au cours de la partie pour représenter les pions. Par ailleurs, des disques verts plus petits s'affichent dans les cases jouables pour guider le joueur humain. Le dessin des différentes formes est géré par la fonction drawPlateau qui utilise le module QPainter de PyQt. Les boutons nous permettent quant à eux de choisir le mode de jeu à travers un menu déroulant (humain contre humain, humain contre IA, IA contre IA), de commencer la partie, de la recommencer ou encore de quitter l'application.

De l'utilisateur vers la machine:
	Sur la première version de l'IHM (console), l'utilisateur a tout d'abord la possibilité de choisir son mode de jeu, à savoir un mode partie simple ou un mode simulation. Pour chaque mode il choisit deux joueurs et il choisit en plus un nombre de tours à simuler pour le mode simulation. Lorsque l'utilisateur est jouer en entrant une commande de type d3 pour jouer sur la case de la colonne D sur la ligne 3. Cette commande est convertie en coordonnées par une fonction nommée inputtotuple. L'utilisateur peut également arrêter la partie à tout moment en entrant la commande q.
	Dans la deuxième version de l'IHM, l'utilisateur peut choisir son mode de jeu. Il dispose pour cela d'un menu déroulant dans lequel il peut sélectionner le mode qui lui convient. Chaque mode possède un indice d'indexation que Python sait reconnaître: il faut pour cela lier l'action "currentIndexChanged" au menu déroulant lors de sa connexion. Lorsque l'utilisateur clique sur un des modes, un entier parmi 0, 1 et 2 est renvoyé, ce qui nous permet ensuite de diriger l'application vers un des trois modes de jeu que nous avons définis. L'utilisateur a également accès à des fonctions simples à travers trois boutons. Il s'agit de simples boutons auxquels nous avons lié l'action clicked lors de leur connexion; il suffit ainsi de cliquer dessus pour déclencher les fonctions auxquelles ils sont connectés. Tout d'abord, en mode IA contre IA, l'utilisateur peut ordonner le départ de la partie lorsqu'il le souhaite. Lorsque l'utilisateur est aussi joueur, la partie début immédiatement (le bouton départ est réglé à True puisqu'inutile, l'utilisateur est en effet maître du temps lorsqu'il joue). Pour recommencer une partie, il existe un bouton recommencer qui efface la partie en cours et réinitialise le plateau (avec les quatre pions au centre). Nous pouvons à partir de là choisir un nouveau mode de jeu et commencer une nouvelle partie. Enfin, notre fenêtre dispose d'un bouton quitter qui permet de fermer l'application. Ce bouton n'est connecté à aucune fonction du fichier applicationIHM.py mais il est directement relié à une fonction close dans QtDesigner.

De la machine vers l'utilisateur:
	Plusieurs informations remontent du programme vers l'utilisateur. Sur la première version de l'IHM (celle affichée dans la console), le programme informera l'utilisateur du numéro du tour, de quel joueur doit jouer et il lui enverra un message lui demandant d'entrer des coordonnées de jeu lorsque son tour est arrivé. Si la case qu'il entre n'est pas jouable ou si le format n'est pas respecté, un message d'erreur est envoyé demandant au joueur de rejouer sur une case valide. En mode partie simple, le plateau de jeu et le score sont affichés à chaque tour. En mode simulation, seul le ratio de victoires est affiché afin de ne pas s'encombrer d'informations inutiles. 



**ARCHITECTURE DU PROGRAMME**

Classes:
[diagramme_plateau.png] [diagramme_pions.png] [diagramme_joueurs.png] [diagramme_IHM.png]

Méthodes:

Tests:
	Toutes les méthodes présentes dans le diagramme de la classe plateau ont été testées progressivement au cours de l'écriture du code, ce qui a permis de résoudre de nombreux problèmes dans les implémentations des règles du jeu et dans les méthodes de la classe joueur. [diagramme_test.png]


**CONCLUSION**

	Grâce à l'implémentation des fonctions et objets précédemment cités, des parties d'othello peuvent être jouées en humain contre humain, humain contre IA et IA contre IA, et ce avec plusieurs IA de différents niveaux. De plus grâce à la fonction stats_jeux du fichier jouer.py, nous pouvons classer les IA selon leur "intelligence" en simulant un grand nombre de parties, ce qui donne par ordre croissant d'intelligence IAalea; IAmax; IAminmax; IAminmax2. Notons que les variantes de l'algorithme min-max, à savoir néga-max et alpha-bêta, ne sont pas plus intelligentes puisque'elle reprennent le principe de min-max. Néanmoins, elle simplifient l'implémentation de l'algorithme min-max, ce qui est utile dans des jeux nécessitant plus de puissance de calcul. Ici, les temps de calcul de l'algorithme min-max restent acceptables. Enfin, une piste d'amélioration serait la création d'une version récursive de min-max, ce qui nous permettrait de donner un paramètre "profondeur" à l'IA et ainsi ne pas avoir à programmer des IA distinctes pour chaque profondeur. Par ailleurs, une implémentation récursive de min-max serait plus rapide, notamment pour des profondeurs de simulation importantes.
	L'interface homme-machine permet quant à elle de visualiser le déroulement d'une partie et de jouer facilement en cliquant simplement sur les cases du plateau. Elle permet également d'étudier le comportement de toutes les intelligences artificielles grâce au mode simulation. Enfin, des paramètres d'ergonomie ont été intégrés tels que la possibilité de quitter, de recommencer une partie sans avoir à relancer le programme ou de lancer une simulation lorsqu'on le souhaite avec le bouton depart. La forme finale de l'iHM correspond bien à la forme souhaitée initialement et permet d'exploiter tout le potentiel de notre jeu, bien que des améliorations graphiques ou des options supplémentaires puissent être apportées.



**RESSOURCES**
[1] https://openclassrooms.com/courses/l-algorithme-min-max
[2] http://pageperso.lif.univ-mrs.fr/~liva.ralaivola/teachings20062005/reversi/MinMaxL2.pdf
[3] https://fr.wikipedia.org/wiki/%C3%89lagage_alpha-b%C3%AAta
Cours d'informatique
Moodle



**ANNEXE**

~mettre la doc python~
















