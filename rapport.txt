INTRODUCTION

Othello, aussi connu sous le nom de Réversi, est un jeu de stratégie à deux joueurs. Il se joue sur un plateau de 64 cases appelé othellier. Le jeu disposent de 64 pions bicolores, noirs d'un côté et blancs de l'autre. Un pion est dit noir (respectivement blanc) si sa face visible est celle de couleur noire (respectivement blanc).
Le but du jeu est d'avoir plus de pions que son adversaire à la fin de la partie. Celle-ci se termine lorsque le plateau est rempli ou qu'aucun des deux joueurs ne peut plus jouer de coup qui soit légal.

Les règles retenues pour notre projet sont les règles classiques, aucune hypothèse simplificatrice ne sera faite. Ces règles sont donc les suivantes:
- au début de la partie, deux pions noirs sont placés en e4 et d5 et deux pions blancs sont placés en d4 et e5 (Figure 1).
- le joueur ayant les pions Noir commence toujours et les deux adversaires jouent ensuite à tour de rôle.
- le jeu se joue tour par tour.
- le joueur pose un pion de sa couleur sur une case vide de l'othellier, adjacente à un pion adverse. Il doit également, en posant son pion, encadrer un ou plusieurs pions adverses entre le pion qu'il pose et un pion à sa couleur, déjà placé sur l'othellier (Figure 2).
- s'il ne peut pas réaliser un coup légal, le joueur passe son tour.



SCHEMA D'UN COUP

Validité du coup:
	Un joueur ne peut jouer un pion que s'il existe une case jouable sur le plateau. Pour s'assurer qu'une case est jouable, nous disposons d'un système de vérification dans l'écosystème (le fichier plateau.py) constitué tout d'abord d'une fonction coupValide. Cette fonction retourne un couple composé d'un booléen et d'une liste de positions. Si la case étudiée est valide, elle renvoie True et la liste des positions des pions adverses à retourner. Sinon, elle renvoie False et une liste vide.
	Dans un premier temps, coupValide va vérifier que la case de départ se situe bien dans les limites du plateau. Si c'est le cas, la fonction va ensuite sélectionner chacune des huit directions à explorer, afin de savoir si des pions adverses peuvent être retournés. Les huit directions possibles ont été définies au préalables dans la fonction increment.
	Une fois toutes les directions  explorées et si des pions adverses peuvent effectivement être gagnés par le joueur, la fonction coupValide rend un couple (True,[liste des pions adverses à retourner]). 

Réalisation du coup:
	C'est ensuite le fonction retourner qui intervient. Placé dans la classe joueur, son rôle est de poser le pion que le joueur veut jouer et de retourner les pions adverses qu'il a gagnés. Pour cela, elle utilise les informations données par coupValide : elle s'assure que la validité du coup vaut True, puis elle parcourt la liste des pions adverses à retourner et les retourne un par un. Dans tous les cas où la case n'est pas jouable (coupValide rend False), la fonction retourner lève une exception ValueError, ce qui permettra à la fonction responsable du bon déroulement de la partie de demander au joueur de joueur sur une case valide.



SCHEMA D'UNE PARTIE

	Les parties sont gérées dans le fichier applicationIHM.py qui utilise en plus des fonctions et objets définis dans l'écosystème.

Initialisation du plateau de jeu:
	Pour commencer une partie d'Othello, il faut d'abord créer un plateau de jeu. Nous utilisons pour cela une fonction generer. Cette fonction crée un objet de type plateau dont les caractéristiques sont décrites dans la classe plateau de l'écosystème. Le plateau est représentée par un dictionnaire. Les clés de ce dictionnaire sont les coordonnées des positions occupées par des pions, les valeurs sont des chaines de caractères 'B' ou 'N'. Les objets pion ainsi créés sont caractérisés par leur position et leur couleur. [[Le choix d'un dictionnaire se justifie par...]]. Le plateau qui est crée contient dans un premier temps quatre pions (deux blancs et deux noirs) disposés selon les règles du jeu. 

Initialisation des joueurs:
	La fonction generer nous permet également d'initialiser les joueurs. Elle crée deux objets de type joueur, un joueur blanc et un joueur noir, en les sélectionnant parmi les sous-classes de la classe joueur de l'écosystème. Ces sous-classes définissent chacune un type de joueur (humain ou intelligence artificielle). Les joueurs sont sémectionnés selon les options cochés par l'utilisateur dans l'interface homme-machine (IHM).

Exécution du jeu et réalisation d'un tour:
	La gestion d'une partie entière se fait au travers de deux tâches : la gestion d'un tour et la gestion de la succession des tours jusqu'à ce que les joueurs ne puissent plus jouer.
	Commençons par la gestion d'un tour, qui se définit comme la succession d'un coup du joueur noir suivi d'un coup du joueur blanc. Nous disposons pour cela d'une fonction tour. Cette fonction fait jouer les deux joueurs l'un après l'autre, en vérifiant à chaque fois que le joueur dispose de cases sur lesquelles il peut jouer. Si tel est le cas, le joueur joue sur la case qu'il a choisie et le plateau est mis à jour et affiché. Si toutefois son coup n'est pas valide, une exception de type ValueError se déclenche, ce qui empêche le plateau d'être modifié et génère un message d'erreur pour que le joueur joue de nouveau. Si un joueur ne dispose pas de case jouable, il passe son tour. 
	La succession des tours est gérée par la fonction partie. En plus d'excuter la fonction tour et de compter les tours, cette fonction permet également d'arrêter le jeu. En effet, la fonction tour renvoie un booléen False si les deux joueurs ne peuvent successivement plus jouer, ce qui correspond à la fin de la partie (situation de blocage ou plateau rempli). A chaque tour, la fonction partie teste ce booléen pour savoir si elle doit continuer ou non la partie.


TYPES DE JOUEURS

	Notre implémentation du jeu Othello permet de faire s'affronter plusieurs types de joueurs : humain contre humain, humain contre IA ou IA contre IA. Nous avons donc créé une classe joueur et des sous-classes représentant chacune un type de joueur qui héritent des propriétés communes des joueurs.

Joueur humain:

IAalea et IAmax (premières IA):

IA Min-Max:

IA Néga-Max:

IA Alpha-Bêta:



INTERACTION AVEC L'UTILISATEUR:

Affichage graphique:
-Interface console IPython
-Interface QtDesigner

De l'utilisateur vers la machine:
-ordre de départ, de recommencer, d'arrêt
-choix des options de jeu

De la machine vers l'utilisateur:
-score, statistiques



DESCRIPTION APPROFONDIE DU PROGRAMME (optionnel):

Classes:

Méthodes:
















